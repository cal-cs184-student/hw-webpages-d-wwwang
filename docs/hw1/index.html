<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-d-wwwang/hw1/">cal-cs184-student.github.io/hw-webpages-d-wwwang/hw1/</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-dwwwang">github.com/cal-cs184-student/hw1-rasterizer-dwwwang</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
  		In this homework, I built a rasterizer from scratch capable of rendering SVG files with triangles, transforms, 
		texture mapping, and antialiasing. Starting from basic triangle rasterization using point-in-triangle tests, I 
		progressively added supersampling for antialiasing, homogeneous coordinate transforms, barycentric color 
		interpolation, and finally texture mapping with both pixel sampling and mipmap level sampling.

  		<br><br>

  		The most interesting thing I learned was how all three antialiasing techniques (supersampling, bilinear pixel 
		sampling, and mipmap level sampling) are solving the same underlying problem (high-frequency content being 
		undersampled) but from different angles. Supersampling brute-forces it by taking more samples per pixel,
		bilinear sampling smooths within a single texture level, and mipmapping prefilters the texture so that minified 
		regions never encounter aliasing in the first place. Seeing how they compose together into trilinear filtering, 
		and understanding the speed and memory tradeoffs of each, has helped me gain a much more concrete understanding of 
		how rendering and rasterizing processes handle texture quality.
		<h2>Task 1: Drawing Single-Color Triangles</h2>

		Rasterization is the sampling of a 2D indicator function.

		<br><br>
		
		I created <code>inside(float x0, float y0, float x1, float y1, float x2, float y2, float sx, float sy)</code>, 
		which takes in the coordinates of a triangle as well as a sample point <code>(sx, sy)</code>. This function takes 
		these points and performs the line equation tests as described in Lecture 2. To account for winding order of the 
		vertices, each AND expression in the OR expression of the return statement checks for either 
		\(>= 0\) (CCW) or \(<= 0\) (CW). 

		<br><br>
		
		Then, I sampled each point within the bounding box of the triangle, ensuring the algorithm is no less efficient 
		than checking only within the bounding box. The bounding box was determined by finding the bottommost, uppermost, 
		leftmost, and rightmost 1D point of the triangle. From there, the sampled point was determined by adding 
		(0.5, 0.5) to each point within the bounding box. For each sampled point, <code>fill_pixel(sx, sy, color)</code> 
		is called if the indicator function <code>inside(x0, y0, x1, y1, x2, y2, sx, sy)</code> returns true.

		<br><br>

		The image below shows <code>svg/basic/test4.svg</code> centered on the red triangle in the middle.
	
		<br><br>

		<figure>
			<img src="task-1.png" style="width:50%"/>
			<figcaption>Task 1: Shapes</figcaption>
		</figure>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		Supersampling is useful in that it reduces aliasing on triangle edges (antialiasing) by testing multiple sample 
		points per pixel instead of just one. Instead of using a binary inside/outside indicator function at each pixel 
		center, I tested an <code>n x n</code> grid of subsamples across each pixel and averaged the ones inside it. 
		As a result, pixels that are partially inside a triangle will have a color proportional to its coverage. This 
		produces smoother edges compared to the jaggies seen at sample rate 1.

		<br><br>

		The main data structure is <code>sample_buffer</code>, which I resized to 
		<code>width x height x sample_rate</code> elements and treated as a virtual high-resolution image of size 
		<code>(width x n) x (height x n)</code> with <code>n = sqrt(sample_rate)</code>. Each output pixel 
		<code>(x, y)</code> corresponds to an <code>n x n</code> block, indexed as
		<code>(y*n + j) * width*n + (x*n + i)</code> with <code>i</code> and <code>j</code> as offsets for each 2D axis.

		<br><br>

		In <code>rasterize_triangle</code>, the inner loop tests each subsample at position 
		<code>(x + (i+0.5)/n, y + (j+0.5)/n)</code> and writes hits directly into the sample buffer. In 
		<code>resolve_to_framebuffer</code>, all <code>n x n</code> subsamples for each pixel are averaged into a single 
		color that is then written to the screen. Points and lines are handled by filling all subsamples of a pixel with 
		the same color in <code>fill_pixel</code>, such that they are not affected by the sample rate.

		<br><br>

		The images below shows <code>svg/basic/test4.svg</code> at sample rates 1, 4, and 16. At rate 1, the corner has jaggies due to 
		aliasing. Furthermore, the corner itself is slightly disconnected due to the pixel centers falling outside of the 
		thin triangle tip. At rates 4 and 16, subsamples near the corner partially cover pixels that were entirely missed
		at rate 1, resulting in a gradual fade rather than the hard cutoff that was observed prior.

		<br><br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task-2-sample-rate-1.png" width="400px"/>
				  <figcaption>Task 2: Sample Rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task-2-sample-rate-4.png" width="400px"/>
				  <figcaption>Task 2: Sample Rate 4</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task-2-sample-rate-16.png" width="400px"/>
				  <figcaption>Task 2: Sample Rate 16</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		I applied a <code>rotate</code> transformation to both arm segments of the right arm, placing it between the 
		<code>translate</code> and <code>scale</code> transformation. This order ensures the right arm is scaled first, 
		then rotated, and finally translated, which avoids the translation from being distorted. The rotation was in 
		negative degrees to rotate it CCW or upwards. 

		<br><br>
		
		I applied another <code>rotate</code> transformation to the outermost arm segment of the left arm, placing it 
		between the <code>translate</code> and <code>scale</code> transformation. Similarly, the same order was used, and 
		the rotation in negative degrees rotates it downwards since the left arm points in the opposite direction from the 
		ight arm.

		<br><br>

		Finally, I adjusted the <code>translate</code> transformation of the outermost arm segment of the left arm to offset it better relative to the innermost arm segment post rotation.

		<br><br>

		The image below shows <code>my-robot.svg</code>.

		<figure>
			<img src="task-3-robot.png" style="width:50%"/>
			<figcaption>Task 3: My Robot Waving</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates represent any point inside a triangle as a weighted linear combination of its three 
		vertices in the form of the following:

		\[(x, y) = \alpha A + \beta B + \gamma C \quad \text{where} \quad \alpha + \beta + \gamma = 1, \quad \alpha,\beta,\gamma \geq 0\]

		Each weight \(\alpha\), \(\beta\), \(\gamma\) represents the distance of the point to each vertex. For instance, 
		at vertex \(A\), \(\alpha=1\) and the other weights are 0. On the other hand, at the centroid of the triangle,
		all weights are equal to \(\frac{1}{3}\).

		Therefore, the color at any interior point is equal to the following weighted linear combination:

		\[\alpha C_A + \beta C_B + \gamma C_C\]

		The image below shows <code>barycentric.svg</code>, a triangle with a blue top vertex (\(\alpha=1\)), red left 
		vertex (\(\beta=1\)), and green right vertex (\(\gamma=1\)). Furthermore, all of its interior points form a
		gradient of colors based on the distance to each vertex.

		<br><br>

		<figure>
			<img src="task-4-barycentric.png" style="width:50%"/>
			<figcaption>Task 4: Barycentric Coordinate Example Triangle</figcaption>
		</figure>

		<br><br>

		The image below shows <code>test7.svg</code>

		<figure>
			<img src="task-4-color-wheel.png" style="width:50%"/>
			<figcaption>Task 4: Color Wheel</figcaption>
		</figure>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is the process of determining the color of a pixel based on a continuous texture coordinate (UV).
		This is used in the rasterization of textured triangles, where UV coordinates are computed at each sample point 
		through barycentric interpolation.

		<br><br>

		This is done in <code>rasterize_textered_triangle</code>, where for each sample point inside the triangle, the
		barycentric weights \(\alpha\), \(\beta\), \(\gamma\) are calculated and then used in the interpolation of the
		UV coordinates from the three vertex UVs. Depending on <code>psm</code>, I performed either nearest or bilinear
		pixel sampling (<code>sample_nearest</code> and <code>sample_bilinear</code> respectively).

		<br><br>

		The nearest pixel sampling method scales the UV coordinate to texel space and finds the nearest integer texel
		through a <code>floor</code> function. This method is overall faster, however it tends to produce more pixelated 
		results when the texture is magnified due to clusters of pixels mapping to the same texel.

		<br><br>

		The bilinear pixel sampling method takes the 4 nearest texels and lerps between them horizontally and vertically
		through the fractional part of the texel coordinate. This method is overall slower compared to the nearest pixel
		sampling method, but it tends to produce smoother results by blending neighboring texels.


		<br><br>

		The images below shows <code>svg/texmap/test1.svg</code> using nearest and bilinear pixel sampling at rates 1 and 16.
		The images produced using nearest pixel sampling are noticeably more pixelated when magnified (or when one texel 
		covers many pixels). This is due to nearest pixel sampling creating hard boundaries whereas bilinear pixel sampling
		smooths these boundaries. At higher supersampling rates, the difference between the two methods is smaller since 
		supersampling performs the averaging of multiple samples per pixel itself, providing a better approximation regardless
		of the pixel sampling method. When the image is more minified (or when there are many texels per pixel), both pixel
		sampling methods produce similar results, as sampling occurs across a texel dense region.

		<br><br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task-5-nearest-rate-1.png" width="400px"/>
				  <figcaption>Task 5: Nearest Pixel Sampling at Rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task-5-nearest-rate-16.png" width="400px"/>
				  <figcaption>Task 5: Nearest Pixel Sampling at Rate 16</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task-5-bilinear-rate-1.png" width="400px"/>
				  <figcaption>Task 5: Bilinear Pixel Sampling at Rate 1</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task-5-bilinear-rate-16.png" width="400px"/>
				  <figcaption>Task 5: Bilinear Pixel Sampling at Rate 16</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling is the process of selecting the appropriate mipmap level to sample
		from based on how quickly UV coordinates change across the screen. When a texture                           
		is minified (many texels map to one pixel), sampling from the full-resolution
		texture introduces aliasing. Instead, a prefiltered lower-resolution version of                             
		the texture (a mipmap level) is used, where the level is determined by the rate                           
		of change of the UV coordinates across adjacent pixels.

		<br><br>

		This is done in <code>rasterize_textured_triangle</code>, where for each sample
		point the UV differentials <code>du/dx</code>, <code>dv/dx</code>,
		<code>du/dy</code>, <code>dv/dy</code> are precomputed once outside the loop
		from the barycentric increments and stored in <code>sp.p_dx_uv</code> and
		<code>sp.p_dy_uv</code> of the <code>SampleParams</code> struct. These represent
		the UV coordinates at one pixel to the right and one pixel below the current
		sample. In <code>get_level</code>, these difference vectors are scaled by the
		texture dimensions to get the texel-space footprint, and the mipmap level is
		computed as \(\log_2\) of the larger of the two gradient magnitudes, clamped to
		the valid mipmap range.

		<br><br>

		Depending on <code>lsm</code>, I implemented three level sampling methods in
		<code>Texture::sample</code>. When <code>lsm == L_ZERO</code>, the zeroth
		mipmap level (full resolution) is always used. When <code>lsm == L_NEAREST</code>,
		the continuous level from <code>get_level</code> is rounded to the nearest integer
		and that single mipmap level is sampled. When <code>lsm == L_LINEAR</code>, the
		level is kept as a continuous value and two adjacent mipmap levels are sampled and
		linearly blended by the fractional part of the level, which combined with bilinear
		pixel sampling produces trilinear filtering.

		<br><br>

		The three sampling techniques offer different tradeoffs between speed, memory, and
		antialiasing power. Increasing the number of samples per pixel (supersampling)
		produces the strongest antialiasing but scales both in computation and memory as
		\(O(\text{sample rate})\), since the sample buffer grows proportionally. Pixel
		sampling adds minimal memory overhead but bilinear requires 4 texture lookups per
		sample instead of 1, with a moderate improvement in smoothness. Level sampling
		requires storing the full mipmap pyramid, which uses approximately \(\frac{1}{3}\)
		extra memory beyond the base texture, but is computationally cheap and effectively
		reduces aliasing in minified regions. <code>L_NEAREST</code> is faster than
		<code>L_LINEAR</code>, while <code>L_LINEAR</code> (especially combined with
		<code>P_LINEAR</code>) provides the smoothest results at the cost of two texture
		lookups per sample across two mipmap levels.

		<br><br>

		The images below shows <code>svg/texmap/my_texture.svg</code> using the combinations of <code>L_ZERO</code>
		and <code>P_NEAREST</code>, <code>L_ZERO</code> and <code>P_LINEAR</code>,
		<code>L_NEAREST</code> and <code>P_NEAREST</code>, and <code>L_NEAREST</code> and
		<code>P_LINEAR</code>. The <code>L_NEAREST</code> images appear smoother in
		minified regions as lower mipmap levels are used, reducing high-frequency aliasing.
		<code>P_LINEAR</code> further blends texels within a level, contributing additional
		smoothness particularly in magnified regions.

		<br><br>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
				<tr>
				<td style="text-align: center;">
					<img src="task-6-lzero-pnearest.png" width="400px"/>
					<figcaption>Task 6: L_ZERO and P_NEAREST</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="task-6-lzero-plinear.png" width="400px"/>
					<figcaption>Task 6: L_ZERO and P_LINEAR</figcaption>
				</td>
				</tr>
				<tr>
				<td style="text-align: center;">
					<img src="task-6-lnearest-pnearest.png" width="400px"/>
					<figcaption>Task 6: L_NEAREST and P_NEAREST</figcaption>
				</td>
				<td style="text-align: center;">
					<img src="task-6-lnearest-plinear.png" width="400px"/>
					<figcaption>Task 6: L_NEAREST and P_LINEAR</figcaption>
				</td>
				</tr>
			</table>
		</div>

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		TBD!
		</div>
	</body>
</html>